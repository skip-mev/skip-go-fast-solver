// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: order_settlements.sql

package db

import (
	"context"
	"database/sql"
)

const clearInitiateSettlement = `-- name: ClearInitiateSettlement :many
UPDATE order_settlements
SET updated_at=CURRENT_TIMESTAMP, initiate_settlement_tx = null, hyperlane_transfer_id = null, initiate_settlement_tx_time = null, settlement_status = ?
WHERE destination_chain_id=? AND initiate_settlement_tx=?
    RETURNING id, created_at, updated_at, source_chain_id, destination_chain_id, source_chain_gateway_contract_address, amount, profit, order_id, initiate_settlement_tx, complete_settlement_tx, settlement_status, settlement_status_message, hyperlane_transfer_id, initiate_settlement_tx_time
`

type ClearInitiateSettlementParams struct {
	SettlementStatus     string
	DestinationChainID   string
	InitiateSettlementTx sql.NullString
}

func (q *Queries) ClearInitiateSettlement(ctx context.Context, arg ClearInitiateSettlementParams) ([]OrderSettlement, error) {
	rows, err := q.db.QueryContext(ctx, clearInitiateSettlement, arg.SettlementStatus, arg.DestinationChainID, arg.InitiateSettlementTx)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderSettlement
	for rows.Next() {
		var i OrderSettlement
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SourceChainID,
			&i.DestinationChainID,
			&i.SourceChainGatewayContractAddress,
			&i.Amount,
			&i.Profit,
			&i.OrderID,
			&i.InitiateSettlementTx,
			&i.CompleteSettlementTx,
			&i.SettlementStatus,
			&i.SettlementStatusMessage,
			&i.HyperlaneTransferID,
			&i.InitiateSettlementTxTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllOrderSettlementsWithSettlementStatus = `-- name: GetAllOrderSettlementsWithSettlementStatus :many
SELECT id, created_at, updated_at, source_chain_id, destination_chain_id, source_chain_gateway_contract_address, amount, profit, order_id, initiate_settlement_tx, complete_settlement_tx, settlement_status, settlement_status_message, hyperlane_transfer_id, initiate_settlement_tx_time FROM order_settlements WHERE settlement_status = ?
`

func (q *Queries) GetAllOrderSettlementsWithSettlementStatus(ctx context.Context, settlementStatus string) ([]OrderSettlement, error) {
	rows, err := q.db.QueryContext(ctx, getAllOrderSettlementsWithSettlementStatus, settlementStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderSettlement
	for rows.Next() {
		var i OrderSettlement
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SourceChainID,
			&i.DestinationChainID,
			&i.SourceChainGatewayContractAddress,
			&i.Amount,
			&i.Profit,
			&i.OrderID,
			&i.InitiateSettlementTx,
			&i.CompleteSettlementTx,
			&i.SettlementStatus,
			&i.SettlementStatusMessage,
			&i.HyperlaneTransferID,
			&i.InitiateSettlementTxTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderSettlement = `-- name: GetOrderSettlement :one
SELECT id, created_at, updated_at, source_chain_id, destination_chain_id, source_chain_gateway_contract_address, amount, profit, order_id, initiate_settlement_tx, complete_settlement_tx, settlement_status, settlement_status_message, hyperlane_transfer_id, initiate_settlement_tx_time FROM order_settlements WHERE source_chain_id = ? AND source_chain_gateway_contract_address = ? AND order_id = ?
`

type GetOrderSettlementParams struct {
	SourceChainID                     string
	SourceChainGatewayContractAddress string
	OrderID                           string
}

func (q *Queries) GetOrderSettlement(ctx context.Context, arg GetOrderSettlementParams) (OrderSettlement, error) {
	row := q.db.QueryRowContext(ctx, getOrderSettlement, arg.SourceChainID, arg.SourceChainGatewayContractAddress, arg.OrderID)
	var i OrderSettlement
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SourceChainID,
		&i.DestinationChainID,
		&i.SourceChainGatewayContractAddress,
		&i.Amount,
		&i.Profit,
		&i.OrderID,
		&i.InitiateSettlementTx,
		&i.CompleteSettlementTx,
		&i.SettlementStatus,
		&i.SettlementStatusMessage,
		&i.HyperlaneTransferID,
		&i.InitiateSettlementTxTime,
	)
	return i, err
}

const insertOrderSettlement = `-- name: InsertOrderSettlement :one
INSERT INTO order_settlements (
    source_chain_id,
    destination_chain_id,
    source_chain_gateway_contract_address,
    amount,
    profit,
    order_id,
    settlement_status
) VALUES (?, ?, ?, ?, ?, ?, ?) ON CONFLICT DO NOTHING RETURNING id, created_at, updated_at, source_chain_id, destination_chain_id, source_chain_gateway_contract_address, amount, profit, order_id, initiate_settlement_tx, complete_settlement_tx, settlement_status, settlement_status_message, hyperlane_transfer_id, initiate_settlement_tx_time
`

type InsertOrderSettlementParams struct {
	SourceChainID                     string
	DestinationChainID                string
	SourceChainGatewayContractAddress string
	Amount                            string
	Profit                            string
	OrderID                           string
	SettlementStatus                  string
}

func (q *Queries) InsertOrderSettlement(ctx context.Context, arg InsertOrderSettlementParams) (OrderSettlement, error) {
	row := q.db.QueryRowContext(ctx, insertOrderSettlement,
		arg.SourceChainID,
		arg.DestinationChainID,
		arg.SourceChainGatewayContractAddress,
		arg.Amount,
		arg.Profit,
		arg.OrderID,
		arg.SettlementStatus,
	)
	var i OrderSettlement
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SourceChainID,
		&i.DestinationChainID,
		&i.SourceChainGatewayContractAddress,
		&i.Amount,
		&i.Profit,
		&i.OrderID,
		&i.InitiateSettlementTx,
		&i.CompleteSettlementTx,
		&i.SettlementStatus,
		&i.SettlementStatusMessage,
		&i.HyperlaneTransferID,
		&i.InitiateSettlementTxTime,
	)
	return i, err
}

const setCompleteSettlementTx = `-- name: SetCompleteSettlementTx :one
UPDATE order_settlements
SET updated_at=CURRENT_TIMESTAMP, complete_settlement_tx = ?
WHERE source_chain_id = ? AND order_id = ? AND source_chain_gateway_contract_address = ?
    RETURNING id, created_at, updated_at, source_chain_id, destination_chain_id, source_chain_gateway_contract_address, amount, profit, order_id, initiate_settlement_tx, complete_settlement_tx, settlement_status, settlement_status_message, hyperlane_transfer_id, initiate_settlement_tx_time
`

type SetCompleteSettlementTxParams struct {
	CompleteSettlementTx              sql.NullString
	SourceChainID                     string
	OrderID                           string
	SourceChainGatewayContractAddress string
}

func (q *Queries) SetCompleteSettlementTx(ctx context.Context, arg SetCompleteSettlementTxParams) (OrderSettlement, error) {
	row := q.db.QueryRowContext(ctx, setCompleteSettlementTx,
		arg.CompleteSettlementTx,
		arg.SourceChainID,
		arg.OrderID,
		arg.SourceChainGatewayContractAddress,
	)
	var i OrderSettlement
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SourceChainID,
		&i.DestinationChainID,
		&i.SourceChainGatewayContractAddress,
		&i.Amount,
		&i.Profit,
		&i.OrderID,
		&i.InitiateSettlementTx,
		&i.CompleteSettlementTx,
		&i.SettlementStatus,
		&i.SettlementStatusMessage,
		&i.HyperlaneTransferID,
		&i.InitiateSettlementTxTime,
	)
	return i, err
}

const setHyperlaneTransferID = `-- name: SetHyperlaneTransferID :one
UPDATE order_settlements
SET updated_at=CURRENT_TIMESTAMP, hyperlane_transfer_id = ?
WHERE source_chain_id = ? AND order_id = ? AND source_chain_gateway_contract_address = ?
    RETURNING id, created_at, updated_at, source_chain_id, destination_chain_id, source_chain_gateway_contract_address, amount, profit, order_id, initiate_settlement_tx, complete_settlement_tx, settlement_status, settlement_status_message, hyperlane_transfer_id, initiate_settlement_tx_time
`

type SetHyperlaneTransferIDParams struct {
	HyperlaneTransferID               sql.NullInt64
	SourceChainID                     string
	OrderID                           string
	SourceChainGatewayContractAddress string
}

func (q *Queries) SetHyperlaneTransferID(ctx context.Context, arg SetHyperlaneTransferIDParams) (OrderSettlement, error) {
	row := q.db.QueryRowContext(ctx, setHyperlaneTransferID,
		arg.HyperlaneTransferID,
		arg.SourceChainID,
		arg.OrderID,
		arg.SourceChainGatewayContractAddress,
	)
	var i OrderSettlement
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SourceChainID,
		&i.DestinationChainID,
		&i.SourceChainGatewayContractAddress,
		&i.Amount,
		&i.Profit,
		&i.OrderID,
		&i.InitiateSettlementTx,
		&i.CompleteSettlementTx,
		&i.SettlementStatus,
		&i.SettlementStatusMessage,
		&i.HyperlaneTransferID,
		&i.InitiateSettlementTxTime,
	)
	return i, err
}

const setInitiateSettlementTx = `-- name: SetInitiateSettlementTx :one
UPDATE order_settlements
SET updated_at=CURRENT_TIMESTAMP, initiate_settlement_tx_time=CURRENT_TIMESTAMP, initiate_settlement_tx = ?
WHERE source_chain_id = ? AND order_id = ? AND source_chain_gateway_contract_address = ?
    RETURNING id, created_at, updated_at, source_chain_id, destination_chain_id, source_chain_gateway_contract_address, amount, profit, order_id, initiate_settlement_tx, complete_settlement_tx, settlement_status, settlement_status_message, hyperlane_transfer_id, initiate_settlement_tx_time
`

type SetInitiateSettlementTxParams struct {
	InitiateSettlementTx              sql.NullString
	SourceChainID                     string
	OrderID                           string
	SourceChainGatewayContractAddress string
}

func (q *Queries) SetInitiateSettlementTx(ctx context.Context, arg SetInitiateSettlementTxParams) (OrderSettlement, error) {
	row := q.db.QueryRowContext(ctx, setInitiateSettlementTx,
		arg.InitiateSettlementTx,
		arg.SourceChainID,
		arg.OrderID,
		arg.SourceChainGatewayContractAddress,
	)
	var i OrderSettlement
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SourceChainID,
		&i.DestinationChainID,
		&i.SourceChainGatewayContractAddress,
		&i.Amount,
		&i.Profit,
		&i.OrderID,
		&i.InitiateSettlementTx,
		&i.CompleteSettlementTx,
		&i.SettlementStatus,
		&i.SettlementStatusMessage,
		&i.HyperlaneTransferID,
		&i.InitiateSettlementTxTime,
	)
	return i, err
}

const setSettlementStatus = `-- name: SetSettlementStatus :one
UPDATE order_settlements
SET updated_at=CURRENT_TIMESTAMP, settlement_status = ?, settlement_status_message = ?
WHERE source_chain_id = ? AND order_id = ? AND source_chain_gateway_contract_address = ?
    RETURNING id, created_at, updated_at, source_chain_id, destination_chain_id, source_chain_gateway_contract_address, amount, profit, order_id, initiate_settlement_tx, complete_settlement_tx, settlement_status, settlement_status_message, hyperlane_transfer_id, initiate_settlement_tx_time
`

type SetSettlementStatusParams struct {
	SettlementStatus                  string
	SettlementStatusMessage           sql.NullString
	SourceChainID                     string
	OrderID                           string
	SourceChainGatewayContractAddress string
}

func (q *Queries) SetSettlementStatus(ctx context.Context, arg SetSettlementStatusParams) (OrderSettlement, error) {
	row := q.db.QueryRowContext(ctx, setSettlementStatus,
		arg.SettlementStatus,
		arg.SettlementStatusMessage,
		arg.SourceChainID,
		arg.OrderID,
		arg.SourceChainGatewayContractAddress,
	)
	var i OrderSettlement
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SourceChainID,
		&i.DestinationChainID,
		&i.SourceChainGatewayContractAddress,
		&i.Amount,
		&i.Profit,
		&i.OrderID,
		&i.InitiateSettlementTx,
		&i.CompleteSettlementTx,
		&i.SettlementStatus,
		&i.SettlementStatusMessage,
		&i.HyperlaneTransferID,
		&i.InitiateSettlementTxTime,
	)
	return i, err
}
