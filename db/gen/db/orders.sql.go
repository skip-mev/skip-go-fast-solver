// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: orders.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const getAllOrdersWithOrderStatus = `-- name: GetAllOrdersWithOrderStatus :many
SELECT id, created_at, updated_at, source_chain_id, destination_chain_id, source_chain_gateway_contract_address, sender, recipient, amount_in, amount_out, nonce, order_id, timeout_timestamp, order_creation_tx, order_creation_tx_block_height, data, filler, fill_tx, refund_tx, order_status, order_status_message FROM orders WHERE order_status = ?
`

func (q *Queries) GetAllOrdersWithOrderStatus(ctx context.Context, orderStatus string) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getAllOrdersWithOrderStatus, orderStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SourceChainID,
			&i.DestinationChainID,
			&i.SourceChainGatewayContractAddress,
			&i.Sender,
			&i.Recipient,
			&i.AmountIn,
			&i.AmountOut,
			&i.Nonce,
			&i.OrderID,
			&i.TimeoutTimestamp,
			&i.OrderCreationTx,
			&i.OrderCreationTxBlockHeight,
			&i.Data,
			&i.Filler,
			&i.FillTx,
			&i.RefundTx,
			&i.OrderStatus,
			&i.OrderStatusMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderByOrderID = `-- name: GetOrderByOrderID :one
SELECT id, created_at, updated_at, source_chain_id, destination_chain_id, source_chain_gateway_contract_address, sender, recipient, amount_in, amount_out, nonce, order_id, timeout_timestamp, order_creation_tx, order_creation_tx_block_height, data, filler, fill_tx, refund_tx, order_status, order_status_message FROM orders WHERE order_id = ?
`

func (q *Queries) GetOrderByOrderID(ctx context.Context, orderID string) (Order, error) {
	row := q.db.QueryRowContext(ctx, getOrderByOrderID, orderID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SourceChainID,
		&i.DestinationChainID,
		&i.SourceChainGatewayContractAddress,
		&i.Sender,
		&i.Recipient,
		&i.AmountIn,
		&i.AmountOut,
		&i.Nonce,
		&i.OrderID,
		&i.TimeoutTimestamp,
		&i.OrderCreationTx,
		&i.OrderCreationTxBlockHeight,
		&i.Data,
		&i.Filler,
		&i.FillTx,
		&i.RefundTx,
		&i.OrderStatus,
		&i.OrderStatusMessage,
	)
	return i, err
}

const insertOrder = `-- name: InsertOrder :one
INSERT INTO orders (
    source_chain_id,
    destination_chain_id,
    source_chain_gateway_contract_address,
    sender,
    recipient,
    amount_in,
    amount_out,
    nonce,
    data,
    order_creation_tx,
    order_creation_tx_block_height,
    order_id,
    order_status,
    timeout_timestamp
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) ON CONFLICT DO NOTHING RETURNING id, created_at, updated_at, source_chain_id, destination_chain_id, source_chain_gateway_contract_address, sender, recipient, amount_in, amount_out, nonce, order_id, timeout_timestamp, order_creation_tx, order_creation_tx_block_height, data, filler, fill_tx, refund_tx, order_status, order_status_message
`

type InsertOrderParams struct {
	SourceChainID                     string
	DestinationChainID                string
	SourceChainGatewayContractAddress string
	Sender                            []byte
	Recipient                         []byte
	AmountIn                          string
	AmountOut                         string
	Nonce                             int64
	Data                              sql.NullString
	OrderCreationTx                   string
	OrderCreationTxBlockHeight        int64
	OrderID                           string
	OrderStatus                       string
	TimeoutTimestamp                  time.Time
}

func (q *Queries) InsertOrder(ctx context.Context, arg InsertOrderParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, insertOrder,
		arg.SourceChainID,
		arg.DestinationChainID,
		arg.SourceChainGatewayContractAddress,
		arg.Sender,
		arg.Recipient,
		arg.AmountIn,
		arg.AmountOut,
		arg.Nonce,
		arg.Data,
		arg.OrderCreationTx,
		arg.OrderCreationTxBlockHeight,
		arg.OrderID,
		arg.OrderStatus,
		arg.TimeoutTimestamp,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SourceChainID,
		&i.DestinationChainID,
		&i.SourceChainGatewayContractAddress,
		&i.Sender,
		&i.Recipient,
		&i.AmountIn,
		&i.AmountOut,
		&i.Nonce,
		&i.OrderID,
		&i.TimeoutTimestamp,
		&i.OrderCreationTx,
		&i.OrderCreationTxBlockHeight,
		&i.Data,
		&i.Filler,
		&i.FillTx,
		&i.RefundTx,
		&i.OrderStatus,
		&i.OrderStatusMessage,
	)
	return i, err
}

const setFillTx = `-- name: SetFillTx :one
UPDATE orders
SET updated_at=CURRENT_TIMESTAMP, fill_tx = ?, filler = ?, order_status = ?
WHERE source_chain_id = ? AND order_id = ? AND source_chain_gateway_contract_address = ?
    RETURNING id, created_at, updated_at, source_chain_id, destination_chain_id, source_chain_gateway_contract_address, sender, recipient, amount_in, amount_out, nonce, order_id, timeout_timestamp, order_creation_tx, order_creation_tx_block_height, data, filler, fill_tx, refund_tx, order_status, order_status_message
`

type SetFillTxParams struct {
	FillTx                            sql.NullString
	Filler                            sql.NullString
	OrderStatus                       string
	SourceChainID                     string
	OrderID                           string
	SourceChainGatewayContractAddress string
}

func (q *Queries) SetFillTx(ctx context.Context, arg SetFillTxParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, setFillTx,
		arg.FillTx,
		arg.Filler,
		arg.OrderStatus,
		arg.SourceChainID,
		arg.OrderID,
		arg.SourceChainGatewayContractAddress,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SourceChainID,
		&i.DestinationChainID,
		&i.SourceChainGatewayContractAddress,
		&i.Sender,
		&i.Recipient,
		&i.AmountIn,
		&i.AmountOut,
		&i.Nonce,
		&i.OrderID,
		&i.TimeoutTimestamp,
		&i.OrderCreationTx,
		&i.OrderCreationTxBlockHeight,
		&i.Data,
		&i.Filler,
		&i.FillTx,
		&i.RefundTx,
		&i.OrderStatus,
		&i.OrderStatusMessage,
	)
	return i, err
}

const setOrderStatus = `-- name: SetOrderStatus :one
UPDATE orders
SET updated_at=CURRENT_TIMESTAMP, order_status = ?, order_status_message = ?
WHERE source_chain_id = ? AND order_id = ? AND source_chain_gateway_contract_address = ?
    RETURNING id, created_at, updated_at, source_chain_id, destination_chain_id, source_chain_gateway_contract_address, sender, recipient, amount_in, amount_out, nonce, order_id, timeout_timestamp, order_creation_tx, order_creation_tx_block_height, data, filler, fill_tx, refund_tx, order_status, order_status_message
`

type SetOrderStatusParams struct {
	OrderStatus                       string
	OrderStatusMessage                sql.NullString
	SourceChainID                     string
	OrderID                           string
	SourceChainGatewayContractAddress string
}

func (q *Queries) SetOrderStatus(ctx context.Context, arg SetOrderStatusParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, setOrderStatus,
		arg.OrderStatus,
		arg.OrderStatusMessage,
		arg.SourceChainID,
		arg.OrderID,
		arg.SourceChainGatewayContractAddress,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SourceChainID,
		&i.DestinationChainID,
		&i.SourceChainGatewayContractAddress,
		&i.Sender,
		&i.Recipient,
		&i.AmountIn,
		&i.AmountOut,
		&i.Nonce,
		&i.OrderID,
		&i.TimeoutTimestamp,
		&i.OrderCreationTx,
		&i.OrderCreationTxBlockHeight,
		&i.Data,
		&i.Filler,
		&i.FillTx,
		&i.RefundTx,
		&i.OrderStatus,
		&i.OrderStatusMessage,
	)
	return i, err
}

const setRefundTx = `-- name: SetRefundTx :one
UPDATE orders
SET updated_at=CURRENT_TIMESTAMP, refund_tx = ?, order_status = ?
WHERE source_chain_id = ? AND order_id = ? AND source_chain_gateway_contract_address = ?
    RETURNING id, created_at, updated_at, source_chain_id, destination_chain_id, source_chain_gateway_contract_address, sender, recipient, amount_in, amount_out, nonce, order_id, timeout_timestamp, order_creation_tx, order_creation_tx_block_height, data, filler, fill_tx, refund_tx, order_status, order_status_message
`

type SetRefundTxParams struct {
	RefundTx                          sql.NullString
	OrderStatus                       string
	SourceChainID                     string
	OrderID                           string
	SourceChainGatewayContractAddress string
}

func (q *Queries) SetRefundTx(ctx context.Context, arg SetRefundTxParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, setRefundTx,
		arg.RefundTx,
		arg.OrderStatus,
		arg.SourceChainID,
		arg.OrderID,
		arg.SourceChainGatewayContractAddress,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SourceChainID,
		&i.DestinationChainID,
		&i.SourceChainGatewayContractAddress,
		&i.Sender,
		&i.Recipient,
		&i.AmountIn,
		&i.AmountOut,
		&i.Nonce,
		&i.OrderID,
		&i.TimeoutTimestamp,
		&i.OrderCreationTx,
		&i.OrderCreationTxBlockHeight,
		&i.Data,
		&i.Filler,
		&i.FillTx,
		&i.RefundTx,
		&i.OrderStatus,
		&i.OrderStatusMessage,
	)
	return i, err
}
