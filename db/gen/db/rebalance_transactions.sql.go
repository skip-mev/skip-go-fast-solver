// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: rebalance_transactions.sql

package db

import (
	"context"
	"time"
)

const getAllPendingRebalanceTransfers = `-- name: GetAllPendingRebalanceTransfers :many
SELECT 
    id,
    tx_hash,
    source_chain_id,
    destination_chain_id,
    amount,
    created_at
FROM rebalance_transfers 
WHERE status = 'PENDING'
`

type GetAllPendingRebalanceTransfersRow struct {
	ID                 int64
	TxHash             string
	SourceChainID      string
	DestinationChainID string
	Amount             string
	CreatedAt          time.Time
}

func (q *Queries) GetAllPendingRebalanceTransfers(ctx context.Context) ([]GetAllPendingRebalanceTransfersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPendingRebalanceTransfers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPendingRebalanceTransfersRow
	for rows.Next() {
		var i GetAllPendingRebalanceTransfersRow
		if err := rows.Scan(
			&i.ID,
			&i.TxHash,
			&i.SourceChainID,
			&i.DestinationChainID,
			&i.Amount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingRebalanceTransfersToChain = `-- name: GetPendingRebalanceTransfersToChain :many
SELECT 
    id,
    tx_hash,
    source_chain_id,
    destination_chain_id,
    amount
FROM rebalance_transfers
WHERE destination_chain_id = ? AND status = 'PENDING'
`

type GetPendingRebalanceTransfersToChainRow struct {
	ID                 int64
	TxHash             string
	SourceChainID      string
	DestinationChainID string
	Amount             string
}

func (q *Queries) GetPendingRebalanceTransfersToChain(ctx context.Context, destinationChainID string) ([]GetPendingRebalanceTransfersToChainRow, error) {
	rows, err := q.db.QueryContext(ctx, getPendingRebalanceTransfersToChain, destinationChainID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingRebalanceTransfersToChainRow
	for rows.Next() {
		var i GetPendingRebalanceTransfersToChainRow
		if err := rows.Scan(
			&i.ID,
			&i.TxHash,
			&i.SourceChainID,
			&i.DestinationChainID,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertRebalanceTransfer = `-- name: InsertRebalanceTransfer :one
INSERT INTO rebalance_transfers (
    tx_hash,
    source_chain_id,
    destination_chain_id,
    amount
) VALUES (?, ?, ?, ?) RETURNING id
`

type InsertRebalanceTransferParams struct {
	TxHash             string
	SourceChainID      string
	DestinationChainID string
	Amount             string
}

func (q *Queries) InsertRebalanceTransfer(ctx context.Context, arg InsertRebalanceTransferParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertRebalanceTransfer,
		arg.TxHash,
		arg.SourceChainID,
		arg.DestinationChainID,
		arg.Amount,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateTransferStatus = `-- name: UpdateTransferStatus :exec
UPDATE rebalance_transfers
SET updated_at=CURRENT_TIMESTAMP, status = ?
WHERE id = ?
`

type UpdateTransferStatusParams struct {
	Status string
	ID     int64
}

func (q *Queries) UpdateTransferStatus(ctx context.Context, arg UpdateTransferStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateTransferStatus, arg.Status, arg.ID)
	return err
}
